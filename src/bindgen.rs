use crate::metadata::{Method, TypeDefinition};
use crate::metadata::{MethodTable, TypeDefOrRef, TypeDefinitionTable, TypeReferenceTable};
use crate::Assembly;
use std::collections::{HashMap, HashSet};
use std::fs::File;
use std::io::Write;
use std::path::Path;
use std::path::PathBuf;
#[derive(Debug)]
pub enum BindgenError {
    IoError(std::io::Error),
    MissingTypeData,
}
fn escape_method(s: &str) -> String {
    s.replace(".ctor", "new").replace(".", "_")
}
fn escape_namespace(s: &str) -> String {
    s.replace(".", "_")
}
impl From<std::io::Error> for BindgenError {
    fn from(err: std::io::Error) -> Self {
        Self::IoError(err)
    }
}
pub struct BindingGenerator {
    assemblies: Vec<Assembly>,
    target: File,
    namespaces_out: HashMap<String, Vec<u8>>,
    //types:HashMap<String,()>,
}
impl BindingGenerator {
    pub fn create<P: AsRef<Path>>(path: P) -> Result<Self, BindgenError> {
        println!("path:{}", path.as_ref().display());
        let mut target = std::fs::OpenOptions::new()
            .write(true)
            .read(true)
            .create(true)
            .open(path)?;
        write!(
            target,
            "// C# bindings generated by wrapped_mono 0.3.2\n#![allow(dead_code)]\n"
        );
        Ok(Self {
            assemblies: Vec::new(),
            target,
            namespaces_out: HashMap::new(),
        })
    }
    pub fn add_assembly(mut self, asm: Assembly) -> Self {
        self.assemblies.push(asm);
        self
    }
    pub fn generate(mut self) -> Result<(), BindgenError> {
        if !self.has_corelib() {
            self.target.write_all(include_bytes!("corelib_binds.rs"))?;
        }
        println!("asmc:{}", self.assemblies.len());
        for assembly_index in 0..self.assemblies.len() {
            let asm = self.assemblies[assembly_index];
            let img = asm.get_image();
            let tdt = match TypeDefinitionTable::from_image(img) {
                Some(tdt) => tdt,
                None => continue,
            };
            let refs = match TypeReferenceTable::from_image(img) {
                Some(refs) => refs,
                None => TypeReferenceTable::empty(),
            };
            //println!("refs:{refs:?}");
            let asm_name = asm.get_name();
            println!("Generating types for assembly {asm_name}");
            self.generate_types(tdt, refs, &asm_name)?;
        }
        for assembly_index in 0..self.assemblies.len() {
            let asm = self.assemblies[assembly_index];
            let img = asm.get_image();
            let tdt = match TypeDefinitionTable::from_image(img) {
                Some(tdt) => tdt,
                None => continue,
            };
            let refs = match TypeReferenceTable::from_image(img) {
                Some(refs) => refs,
                None => TypeReferenceTable::empty(),
            };
            let asm_name = asm.get_name();
            self.generate_methods(tdt, refs, &asm_name)?;
        }
        for (key, value) in self.namespaces_out {
            write!(self.target, "//Implentations for namespace \"{key}\"\n")?;
            if !key.is_empty() {
                write!(self.target, "mod {key}{{\n")?;
                self.target.write_all(&value)?;
                write!(self.target, "}}")?;
            } else {
                self.target.write_all(&value)?;
            }
        }
        Ok(())
    }
    fn has_corelib(&self) -> bool {
        for assembly in &self.assemblies {
            if assembly.get_name() == "mscorlib" {
                return true;
            }
        }
        false
    }
    fn generate_method(
        &mut self,
        tdt: &TypeDefinitionTable,
        refs: &TypeReferenceTable,
        method: &crate::metadata::Method,
        namespace: &str,
        type_name: &str,
    ) -> Result<(), BindgenError> {
        let mut out = self.namespaces_out.get_mut(namespace).unwrap();
        let name = method.name();
        let escaped_name = escape_method(method.name());
        let mut param_names = Vec::with_capacity(method.signature().params().len());
        for param in method.signature().params() {
            let (namespace, name) = if let TypeDefOrRef::TypeDef(index) = param {
                let index = *index;
                let param = &tdt.defs()[index as usize];
                (escape_namespace(param.namespace()), param.name())
            } else if let TypeDefOrRef::TypeRef(index) = param {
                let index = *index;
                let r = match refs.refs().get(index as usize) {
                    Some(r) => r,
                    None => return Ok(()),
                };
                (escape_namespace(r.namespace()), r.name())
            } else {
                break;
            };
            if name.contains('<') || name.contains('`') || name.contains('.') {
                return Ok(());
            }
            //println!("param:{param:?},name:{name}");
            if namespace.is_empty() {
                param_names.push(name.into());
            } else {
                param_names.push(format!("{namespace}::{name}"));
            }
        }
        write!(out, "impl {type_name}_{escaped_name}_DISPATCH_ARGS for (")?;
        if method.signature().flags().has_this() {
            if namespace.is_empty() {
                param_names.push(name.into());
            } else {
                param_names.push(format!("{namespace}::{name}"));
            }
        }
        for param_name in &param_names {
            write!(out, "{param_name},")?;
        }
        write!(out, "){{")?;
        write!(
            out,
            "\n\ttype ReturnType = System::Object;\n\ttype Args = ("
        );
        for param_name in &param_names {
            write!(out, "{param_name},")?;
        }
        write!(out, ");\n\tfn call(args:Args){{todo!()}}\n}}\n//END\n")?;
        //write!(out,"//Method dispatcher\npub struct {escaped_name}_DISPATCHER;\n pub const {escaped_name}:{mname}_DISPATCHER = {mname}_DISPATCHER;\n trait {mname}_DISPATCHER_TRAIT{{type Return; fn invoke(&self)->Return;}}\nimpl {mname}_DISPATCHER {{ fn invoke<Args:{mname}_DISPATCHER_TRAIT>(args:Args)->Args::Return{{args.invoke()}} }}\n")?;
        /*
        write!(out, "// Wrapper around method {mname}\n")?;
        write!(out, "impl {mname}_DISPATCHER_TRAIT for (")?;
        if meth.signature().flags().has_this() {
            println!("{mname} - has this!");
            if namespace.is_empty() {
                write!(out, "{name}")?;
            } else {
                write!(out, "{namespace}::{name}")?;
            }
        }
        for param in meth.signature().params() {
            let (namespace, name) = if let TypeDefOrRef::TypeDef(index) = param {
                let index = index;
                let param = &tdt.defs()[index as usize];
                (escape_namespace(param.namespace()), param.name())
            } else if let TypeDefOrRef::TypeRef(index) = param {
                let index = *index;
                let r = &refs.refs()[index as usize];
                (escape_namespace(r.namespace()), r.name())
            } else {
                break;
            };
            println!("param:{param:?},name:{name}");
            if namespace.is_empty() {
                write!(out, "{name}")?;
            } else {
                write!(out, "{namespace}::{name}")?;
            }
        }
        write!(out, "){{")?;
        write!(out, "todo!();");
        write!(out, "}}")?;
        */
        Ok(())
    }
    fn generate_methods(
        &mut self,
        tdt: TypeDefinitionTable,
        refs: TypeReferenceTable,
        asm_name: &str,
    ) -> Result<(), BindgenError> {
        for td in tdt.defs() {
            let namespace = escape_namespace(td.namespace());
            self.create_namespace(&namespace);
            let type_name = td.name();
            if type_name.contains('<') || type_name.contains('`') {
                continue;
            }
            //let type_name = escaped_name(type_name);
            {
                let mut out = self.namespaces_out.get_mut(&namespace).unwrap();
                write!(out, "//Implementations of methods for {type_name}\n")?;
            }
            let mut methods: std::collections::HashSet<String> = HashSet::new();
            for method in td.methods() {
                let name = method.name();
                if name.contains('<')
                    || name.contains('>')
                    || name.contains('`')
                    || name.contains('.')
                {
                    continue;
                }
                self.generate_method(&tdt, &refs, method, &namespace, &type_name)?;
                let mut out = self.namespaces_out.get_mut(&namespace).unwrap();
                let escaped_name = escape_method(method.name());
                assert!(!escaped_name.contains('.'));
                if !methods.contains(&escaped_name) {
                    write!(out, "trait {type_name}_{escaped_name}_DISPATCH_ARGS{{\n\ttype ReturnType;\n\ttype Args;\n\tfn call(args:Args)->Result<ReturnType,Exception>;\n\t//END\n}}\n");
                    methods.insert(escaped_name.clone());
                }
            }
            {
                let mut out = self.namespaces_out.get_mut(&namespace).unwrap();
                write!(out, "//End of Implementations of methods for {type_name}\n")?;
            }
        }
        Ok(())
    }
    fn generate_types(
        &mut self,
        tdt: TypeDefinitionTable,
        refs: TypeReferenceTable,
        asm_name: &str,
    ) -> Result<(), BindgenError> {
        for td in tdt.defs() {
            use crate::metadata::TypeDefOrRef::TypeDef;
            let name = td.name();
            if name.contains('<') || name.contains('`') {
                continue;
            }
            let namespace = td.namespace();
            let escaped_namespace = escape_namespace(namespace);
            self.create_namespace(&escaped_namespace);
            let mut out = self.namespaces_out.get_mut(&escaped_namespace).unwrap();
            write!(
                out,
                "// Bindings to object \"{name}\" in namespace \"{namespace}\".\n"
            )?;
            write!(out, "struct {name}{{obj:wrapped_mono::Object}}\n");
            write!(out,"impl wrapped_mono::InteropClass for {name}{{
fn get_mono_class()->wrapped_mono::Class{{
    extern crate lazy_static;
    lazy_static::lazy_static!{{
        static ref {name}_CLASS:wrapped_mono::Class = {{
            let img = Assembly::assembly_loaded(\"{asm_name}\")
                .expect(\"Assembly \\\"{asm_name}\\\" is not loaded, could not get \\\"{name}\\\" class!\")
                .get_image();
            Class::from_name_case(&img, \"{namespace}\", \"{name}\")
                .expect(\"Could not get \\\"{name}\\\" class residing in namespace \\\"{namespace}\\\" form assembly \\\"{asm_name}\\\"!\")
        }};
    }}
    *{name}_CLASS
    }}
}}\n");
            write!(
                out,
                "impl wrapped_mono::ObjectTrait for {name}{{
    fn get_ptr(&self)->*mut wrapped_mono::binds::MonoObject{{
        self.object.get_ptr()
    }}
    unsafe fn from_ptr_unchecked(ptr:*mut wrapped_mono::binds::MonoObject)->Self{{
        let object = wrapped_mono::Object::from_ptr_unchecked(ptr);
        Self{{object}}
    }}
}}\n"
            )?;
            if !td.extends().is_null() {
                let (t_namespace, t_name) = if let TypeDef(index) = td.extends() {
                    let index = index - 1;
                    let td = &tdt.defs()[index as usize];
                    (escape_namespace(td.namespace()), td.name())
                } else if let TypeDefOrRef::TypeRef(index) = td.extends() {
                    let index = index - 1;
                    let r = &refs.refs()[index as usize];
                    (escape_namespace(r.namespace()), r.name())
                } else {
                    break;
                };
                if t_namespace.is_empty() {
                    write!(out, "impl Into<{t_name}> ")?;
                } else {
                    write!(out, "impl Into<{t_namespace}::{t_name}> ")?;
                }
                write!(
                    out,
                    "for {name}{{
    fn into(self)->{t_namespace}::{t_name}{{
        //All bindgen objects have identical layout
        unsafe{{std::mem::transmute(self)}}
    }}
}}"
                )?;
            }
        }
        Ok(())
    }
    //Inserts a namespace if it is not present
    fn create_namespace(&mut self, namespace: &str) {
        if let Some(out) = self.namespaces_out.get_mut(namespace) {
            return;
        }
        self.namespaces_out.insert(namespace.to_owned(), Vec::new());
    }
}
/*
pub fn generate_binds<P:AsRef<Path>>(path:P,assembly:Assembly)->Result<(),BindgenError>{
    use crate::metadata::{TypeDefinitionTable,TypeReferenceTable};
    // Prepare
    let file = File::open(path).unwrap();
    // Generate
    let asm_name = assembly.get_name();
    let img = assembly.get_image();
    let tdt = TypeDefinitionTable::from_image(img).ok_or(BindgenError::MissingTypeData)?;
    let trt = TypeReferenceTable::from_image(img).ok_or(BindgenError::MissingTypeData)?;
    println!("trt:{trt:?}\n\n\ntdt:{tdt:?}");
    for td in tdt.defs(){
        emmit_bind_for_tdt(path.as_ref(),td,&asm_name)?
    }
    //todo!("tdt:{tdt:?}");
    Ok(())
}
fn impl_method(method:&Method,out:&mut Vec<u8>)->Result<(),BindgenError> {
    write!(out,"\n\t//Implenting method {name}",name = method.name())?;
    Ok(())
}
fn impl_methods(td:&TypeDefinition,file:&mut File)->Result<(),BindgenError> {
    let mut out = Vec::new();
    let name = td.name();
    write!(out,"impl {name} {{")?;
    let mut index = 0;
    let method_count = td.methods().len();
    for method in td.methods(){
        impl_method(method,&mut out)?;
    }
    write!(out,"\n}}\n")?;
    file.write_all(&out)?;
    Ok(())
}
fn emmit_bind_for_tdt(out:&mut File,td:&TypeDefinition,asm_name:&str)->Result<(),BindgenError> {
    //Skip types with invalid names.
    if td.name().contains('<'){
        return Ok(());
    }
    write!(out,"// Bindings to object \"{name}\" in namespace \"{namespace}\".\n",name = td.name(), namespace = td.namespace())?;
    let name = td.name();
    let namespace = td.namespace();
    write!(out,"impl wrapped_mono::InteropClass for {name}{{
    #[allow(non_upper_case_globals)]
    fn get_mono_class()->wrapped_mono::Class{{
        extern crate lazy_static;
        use lazy_static::*;
        lazy_static!{{
            static ref {name}_CLASS:wrapped_mono::Class = {{
                 let img = Assembly::assembly_loaded(\"{asm_name}\")
                    .expect(\"Assembly \\\"{asm_name}\\\" is not loaded, could not get \\\"{name}\\\" class!\")
                    .get_image();
                Class::from_name_case(&img, \"{namespace}\", \"{name}\")
                    .expect(\"Could not get \\\"{name}\\\" class residing in namespace \\\"{namespace}\\\" form assembly \\\"{asm_name}\\\"!\")
            }};
        }}
        *{name}_CLASS
    }}
}}\n")?;
    write!(out,"struct {name}{{
    object:wrapped_mono::Object,
}}\n")?;
    write!(out,"impl wrapped_mono::ObjectTrait for {name}{{
    fn get_ptr(&self)->*mut wrapped_mono::binds::MonoObject{{
        self.object.get_ptr()
    }}
    unsafe fn from_ptr_unchecked(ptr:*mut wrapped_mono::binds::MonoObject)->Self{{
        let object = wrapped_mono::Object::from_ptr_unchecked(ptr);
        Self{{object}}
    }}
}}\n")?;
    impl_methods(td,&mut out)?;
    Ok(())
}*/
